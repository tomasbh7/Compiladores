#ifndef NFA_H
#define NFA_H

#include "regex.h"
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/**
 * @brief Maximum number of states supported by the NFA.
 *
 * The implementation uses a 64-bit bitmask to represent
 * state sets, therefore the limit is 64 states.
 */
#define MAX_STATES 64

/**
 * @brief Maximum number of symbols supported in the alphabet.
 */
#define MAX_SYMBOLS 256


/**
 * @brief Internal representation of the epsilon symbol.
 *
 * This value is reserved and must not conflict
 * with user-defined input symbols.
 */
#define EPSILON_SYMBOL 240


/**
 * @brief Represents the alphabet of the NFA.
 *
 * symbols:
 *     Array storing the symbols used by the automaton.
 *
 * char_to_col:
 *     Maps an ASCII character to its corresponding column
 *     index in the transition matrix. If the value is -1,
 *     the symbol is not part of the alphabet.
 *
 * symbol_count:
 *     Total number of registered symbols.
 */
typedef struct {
    char symbols[MAX_SYMBOLS];      // Símbolos del alfabeto
    int char_to_col[256];           // Mapeo char -> columna
    uint16_t symbol_count;          // Cantidad de símbolos
} alphabet;


/**
 * @brief Represents a transition during Thompson construction.
 *
 * Used only while building the NFA before the final
 * transition matrix is generated.
 */
typedef struct {
    uint8_t from_state;
    char symbol;
    uint8_t to_state;
} t_transition;


/**
 * @brief Represents a temporary NFA fragment.
 *
 * Each fragment has:
 *  - A start state
 *  - An end (accepting) state
 *
 * These fragments are combined using Thompson operators.
 */
typedef struct {
    uint8_t start;
    uint8_t end;
} t_nfa;


/**
 * @brief Manages states and transitions during construction.
 *
 * This structure is used only while building the NFA.
 *
 * next_id:
 *     Next available state identifier.
 *
 * states_count:
 *     Total number of created states.
 *
 * transitions:
 *     List of temporary transitions generated by
 *     Thompson's construction.
 *
 * manager_alphabet:
 *     Alphabet collected during construction.
 */
typedef struct {
    uint8_t next_id;
    uint8_t states_count;
    uint8_t states[MAX_STATES];

    uint16_t transitions_count;
    t_transition transitions[MAX_STATES * 4]; 
    /* MAX_STATES * 4 es suficiente para Thompson:
       cada operador agrega pocas transiciones */

    alphabet manager_alphabet;
} states_manager;


/**
 * @brief Represents the final Non-deterministic Finite Automaton.
 *
 * start_state:
 *     Initial state of the automaton.
 *
 * states:
 *     Total number of states.
 *
 * accept_states:
 *     Bitmask representing accepting states.
 *
 * alphabet:
 *     Alphabet used by the automaton.
 *
 * transitions:
 *     Dynamic 2D matrix:
 *         states × alphabet.symbol_count
 *
 *     Each entry is a 64-bit bitmask indicating
 *     the set of reachable states.
 *
 * epsilon_closures:
 *     Cached epsilon-closure for each state.
 */
typedef struct {
    uint8_t start_state;
    uint8_t states;
    uint64_t accept_states;   // bitset de aceptación
    alphabet alphabet;
    uint64_t **transitions;    /* Matriz dinámica: states x alpha.symbol_count */
    uint64_t *epsilon_closures;  /* Cache de clausuras epsilon */
} nfa;


/**
 * @brief Creates and initializes a new alphabet.
 *
 * @return Initialized alphabet structure.
 */
alphabet new_alphabet(void);


/**
 * @brief Adds a symbol to the alphabet if not already present.
 *
 * @param a Pointer to the alphabet.
 * @param symbol Character to register.
 */
void add_symbol(alphabet *a, char symbol);


/**
 * @brief Creates a new states manager.
 *
 * @return Initialized states manager.
 */
states_manager new_states_manager(void);

/**
 * @brief Creates a new state.
 *
 * @param manager Pointer to the states manager.
 * @return ID of the newly created state.
 */
uint8_t new_state(states_manager *manager);

/**
 * @brief Adds a transition during construction.
 *
 * @param manager Pointer to the states manager.
 * @param from Source state.
 * @param symbol Transition symbol.
 * @param to Destination state.
 */
void add_transition(states_manager *manager,
                    uint8_t from,
                    char symbol,
                    uint8_t to);

/**
 * @brief Creates an NFA fragment for a single symbol.
 */
t_nfa symbol_nfa(states_manager *manager, char symbol);

/**
 * @brief Concatenates two NFA fragments.
 */
t_nfa concat_nfa(states_manager *manager, t_nfa *a, t_nfa *b);

/**
 * @brief Creates the union (alternation) of two fragments.
 */
t_nfa union_nfa(states_manager *manager, t_nfa *a, t_nfa *b);

/**
 * @brief Applies Kleene star (*) to a fragment.
 */
t_nfa kleene_closure_nfa(states_manager *manager, t_nfa *a);

/**
 * @brief Applies positive closure (+) to a fragment.
 */
t_nfa positive_closure_nfa(states_manager *manager, t_nfa *a);

/**
 * @brief Applies optional operator (?) to a fragment.
 */
t_nfa optional_nfa(states_manager *manager, t_nfa *a);


/**
 * @brief Converts a temporary Thompson NFA into the final NFA.
 *
 * @param temp Final fragment.
 * @param manager Construction manager.
 * @return Fully constructed NFA.
 */
nfa t_nfa_to_nfa(t_nfa temp, states_manager manager);

/**
 * @brief Converts a postfix regular expression into an NFA.
 *
 * @param r Postfix regular expression.
 * @return Constructed NFA.
 */
nfa regex_to_nfa(const regex r);

/**
 * @brief Computes epsilon-closures for all states.
 */
void calculate_epsilon_closure(nfa *automaton);

/**
 * @brief Computes epsilon-closure for a single state.
 */
void epsilon_closure(nfa *automaton, uint8_t state);

/**
 * @brief Simulates the NFA on an input string.
 *
 * @param automaton NFA to simulate.
 * @param input Input string.
 * @param input_length Length of the input.
 * @return true if the input matches, false otherwise.
 */
bool match_nfa(nfa automaton,
               const char *input,
               size_t input_length);

#endif /* NFA_H */